# ChatGPT-Conversation-Pruner

一个用于**缓解 ChatGPT 长对话场景下前端性能问题**的 Tampermonkey 用户脚本。

该脚本通过在对话 DOM 达到“稳定态”后，**动态剪枝较早的对话轮次（turn）**，以降低页面中同时存在的 DOM 节点数量，从而改善滚动、输入和渲染时的卡顿问题。

脚本仅在对话页面生效，不拦截网络请求，不收集任何数据。

> 脚本灵感来自 [ChatGPT 长对话卡顿优化](https://greasyfork.org/zh-CN/scripts/559208-chatgpt-%E9%95%BF%E5%AF%B9%E8%AF%9D%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96)。
> 在其基于 DOM 卸载的优化思路基础上，本脚本进一步引入了**被剪枝 DOM 的缓存、按需恢复以及基于滚动状态的动态 DOM 管控机制**，以适配更长对话和更复杂的前端状态变化。


---

## 快速开始

### 手动安装

1. 打开 Tampermonkey 管理面板，选择「新建脚本」
2. 将 [chatgpt-conversation-pruner.js](chatgpt-conversation-pruner.js) 的内容完整粘贴进去
3. 保存脚本并刷新 ChatGPT 页面

---

## 已实现功能

- **对话稳定态检测**
  - 在流式生成或 React 批量更新过程中不会提前介入
  - 仅当对话 DOM 在连续检测中保持稳定后才开始剪枝

- **动态剪枝旧对话轮次**
  - 页面中仅保留最近 N 条对话轮次（可配置）
  - 更早的轮次会被移出 DOM 并缓存

- **向上滚动恢复历史**
  - 向上滚动触发批量恢复被移除的历史对话
  - 使用哨兵节点 + IntersectionObserver，避免一次性恢复过多 DOM

- **顶部 live / cached 状态指示**
  - 在页面 Header 区域显示当前：
    - `live`：当前实际挂载在 DOM 中的对话轮次数
    - `cached`：已被剪枝、暂存于内存中的历史轮次数
  - 状态会随剪枝、历史恢复和 DOM 重建自动刷新
  - 用于直观观察剪枝是否生效及缓存规模变化

- **回到底部自动恢复剪枝**
  - 当用户从历史区域滚动回对话底部时：
    - 自动退出历史浏览模式
    - 恢复实时模式并重新启用剪枝逻辑
  - 避免在查看历史后，页面持续累积 DOM 节点

- **语音模式安全处理**
  - 在语音相关模式下不直接移除 DOM，仅隐藏旧轮次
  - 避免破坏语音交互流程

- **同路由 DOM 重建防护**
  - 针对 ChatGPT 前端在同一路由下重建对话 DOM 的情况进行检测
  - 自动重绑观察器并执行安全剪枝，防止缓存重复累积

- **生成期剪枝触发**
  - 在新对话轮次生成完成后，自动评估并执行剪枝
  - 避免长时间对话中 DOM 持续增长

- **SPA 路由感知**
  - 支持 ChatGPT 单页应用内的会话切换
  - 路由变化时自动销毁旧实例并创建新实例

---

## 实现原理

### 1. 基本思路

ChatGPT 的长对话页面在前端会累积大量 `article` 级别的 DOM 节点。  
随着轮次增长，滚动、输入和布局计算的开销会明显上升。

本脚本的核心思路是：

> **在不影响当前阅读和交互的前提下，减少同时存在于 DOM 树中的对话轮次数量。**

---

### 2. 稳定态判定

为了避免在以下场景误操作：

- 流式生成过程中
- React 批量 patch 尚未完成时

脚本会周期性检查：

- 当前对话轮次数是否变化
- 最后一个对话轮次的高度是否变化

只有在连续多次检测中均保持稳定，才认为页面进入“稳定态”，并允许后续剪枝逻辑执行。

---

### 3. 剪枝与缓存机制

- 当页面中的对话轮次数超过设定阈值时：
  - 较早的对话轮次会被从 DOM 中移除
  - 对应的 DOM 节点会被缓存到内存中（按会话隔离）
- 缓存数量存在上限，防止无限增长

在需要查看历史时，这些缓存节点可以被重新插入页面。

---

### 4. 历史恢复与滚动控制

- 在对话顶部插入一个不可见的“哨兵节点”
- 使用 `IntersectionObserver` 监听哨兵进入视口
- 当用户向上滚动接近顶部时，分批恢复历史对话

为避免视口跳动，脚本会在恢复前后计算哨兵位置差，并对滚动位置进行补偿。

---

### 5. 滚动容器与状态机

ChatGPT 页面并非始终使用 `window` 作为滚动容器，脚本会动态识别实际的滚动根节点。

基于滚动状态，脚本在以下模式之间切换：

- **实时模式（Live）**：位于底部，允许自动剪枝
- **历史模式（History）**：用户向上查看历史，暂停剪枝
- **语音模式（Voice）**：仅隐藏旧节点，不移除 DOM

---

### 6. DOM 重建防护

在某些情况下，ChatGPT 会在同一路由下整体替换对话 DOM 子树。

脚本通过轻量级看门狗机制检测：

- 对话容器是否被替换
- 哨兵节点是否丢失

一旦检测到异常，会自动重建观察器并执行安全剪枝，避免缓存翻倍或状态错乱。

---

### 7. 边界与限制

- 本脚本依赖 ChatGPT 当前的前端 DOM 结构
- 当 ChatGPT UI 发生较大调整时，可能需要适配更新
- 脚本以“尽力而为”为原则，不保证在所有未来版本中持续有效

---

